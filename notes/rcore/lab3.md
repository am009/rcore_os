# lab3 虚拟内存管理

## Sv39
12位 + 9 + 9 + 9
每页4K, -(512页)-> 2M -(512)-> 1G -> 512G
0x1000 -> 0x20 0000 -> 0x4000 0000 -> 0x80 0000 0000
物理地址有56位. 也就是有56-12=44位标识页
而页表项中53-10这44位标识物理页号. 也就是物理地址的高44位取出来之后还要右移两位才可以
低10位为标志位

然而三级和二级页表项不一定要指向下一级页表, 可以作为大页... 如果RWX位全0才是指向下一级页表, 否则作为大页, 项中指向映射的开始页, 向后自动映射2M/1G内存. 这方法有点秀, 比x86好

Sv39最大支持512G地址空间, 分为3级页表. 每级页表大小都是一页, 因为8B * 512 = 4K. 
最高级的页表, 每一项表示1G的地址空间, 第二级页表每项表示2M地址空间, 最低级的页表每一项表示4K地址空间.
虚拟地址空间64位只有低39位有效, 63-39 位的值必须等于第 38 位的值. 也就是说, 根据最高位是不是1, 512G地址空间被分为低256G(高位都是0), 和高256G(高位都是F).

页表项最低位(V)为0则不合法

要在修改 satp 的指令后面马上使用 sfence.vma 指令刷新整个 TLB。手动修改一个页表项之后可以在sfence.vma后面加上一个虚拟地址，这样 sfence.vma 只会刷新这个虚拟地址的映射。

## 内核启动

内核的地址空间要抬高, 不是平移256G. 数据段起始地址改为
0xffff ffff 8020 0000
0x0000 0000 8020 0000

多了0xffff 0000 0000, 也就是多了508G. 

0x80200000 = 2G + 2M

启动过程:
1. 0x80200000处使用汇编开启分页模式
1. 开启分页模式的一瞬间, 当前的PC还在原来的位置, 因此需要映射0x80200000附近的位置, 同时需要映射0xffffffff80200000 附近的位置 直接使用大页映射, 4K空间映射两个1g, 简单方便.
1. 跳转到rust内

总结一下需要修改的地方
1. ld脚本需要修改链接的基址, 这个比较简单
2. 启动的asm文件, 需要加上临时页表, 和装载临时页表的语句
3. 加入虚拟地址结构体, 实现一些相关trait, 增加一个偏移量常量KERNEL_MAP_OFFSET

修改完这几个, 内核依然能够正常运行.

### entry.asm
```asm
.quad (0x80000 << 10) | 0xcf #由于取页号放到第10位开始的位置, 也就相当于0x8000 0000 >>12 <<10, 0xcf表示 VRWXAD 均为 1 这里Access 和Dirty没必要吧?? 有什么好处??
```

### 虚拟地址
1. 指针转换为虚拟地址, 实现这个trait, 这样任何指针类型都可以之间转虚拟地址类型
2. deref_kernel和deref可以用地址类型转换成任意类型的指针, 而且生命周期是static的. pageNumber类型的deref相关直接获得页表大小的u8数组
3. 对VirtualPageNumber类型实现levels函数, 获得三级页号
4. 也为address类型实现page_offset函数, 取得页内偏移.


## 实现页表 src/memory/mapping


## 其他问题

ld脚本中添加对齐的地方
bss 应该不用对齐吧, 和data一起就行? 但是分在不同的页方便映射, 否则要把data段末尾清零.

## 其他知识点

risc-v汇编
op a, b, c 是把b和c运算放到a中.

lui t0, %hi(boot_page_table) 这里hi是什么??

汇编里面的boot_page_table上方的对齐
.align 12 指的难道是对齐低12位为0

panicInfo 里面的信息挺多, 可以打印出文件,行号和列号